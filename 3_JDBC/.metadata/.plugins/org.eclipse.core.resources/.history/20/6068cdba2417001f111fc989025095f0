package edu.kh.jdbc.model.dao;

import java.sql.Connection;
import java.sql.Date;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import edu.kh.jdbc.model.vo.Employee;


// DAO(Date Access Object) : 데이터 접근 객체
// - DB와 연결되어 SQL을 수행하고 결과를 반환 받는 역할
public class EmployeeDAO {

	// JDBC 객체 저장용 참조 변수 필드 선언

	private Connection conn=null;
	//private Connection conn = null; null 값을 넣든 언넣든 똑같다. jvm은 객체가 비어있으면 기본값인 null을 넣어줌
	// DB 연결 정보를 담은 객체(Java -DB 사이의 통로 역할)

	private Statement stmt;
	// Connection 을 통해 SQL을 수행하고 결과를 반환 받는 객체

	private ResultSet rs;

	//SELECT 수행 후 반한되는 객체

	private PreparedStatement pstmt;
	//Statment의 자식으로 좀 더 향상된 기능을 제공
	// -? (위치홀더)를 이용하여 SQL에 작성되어지는 리터럴을 동적으로 제어함
	// --> 오타의 위험 감소, 가독성 상승

	public List<Employee> selectAll() {

		// 결과 저장용 변수 준비
		List<Employee> empList = new ArrayList<>();

		try {
			//1) Orcale JDBC Driver 메모리 로드
			Class.forName("oracle.jdbc.driver.OracleDriver");
			//2) DB 연결 작업(Connection 얻어오기)

			conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe" , "hgh", "hgh1234");
			// DriverManager : Connection 생성 메소드 제공 
			//--> 생성된 커넥션을 이용해 SQL을 수행하면 자동 커밋이 된다(기본값)
			//--> 자동 커밋 기능을 끄고 개발자가 트랜잭션을 직접 제어하는게 좋다.

			//conn.setAutoCommit(false); // 자동 커밋 기능 비활성화
			// --> 자동 커밋을 비활성화 시켜도
			//     conn.close()가 실행되면 남은 트랜잭션 내용이 모두 commit 된다.

			/*

			 ******** 트랜잭션 제어 **********
			if(result>0) {
				conn.commit(); //DML 성공시 commit 수행
			} else {
				conn.rollback(); //DML 실패 시 rollback 수행
			}

			 */


			//3) 수행할 SQL 작성

			String sql = "SELECT * FROM EMPLOYEE2 ORDER BY EMP_ID";
			// *** SQL 작성 시 세미콜론은 업어야 함!! ***
			//4) Statement 객체 생성
			stmt = conn.createStatement(); //커넥션을 왔다 갔다 하는 셔틀버스 같은 역할



			//5) SQL 수행 후 결과(ResultSet) 반환 받기

			rs = stmt.executeQuery(sql); 
			//executeQuery() : select문 수행 후 ResultSet 결과 반환

			//6) 결과를 List에 옮겨 담기
			// -> ResultSet에 한 행씩 접근하여 컬럼값을 얻어와
			//    한 행의 정보가 담긴 Employee 객체를 생성하고
			//    이를 empList에 추가



			while(rs.next()) {
				// rs.next() : 다음 행이 있으면 true, 호출 시 마다 다음 행으로 이동
				int empId= rs.getInt("EMP_ID"); // 사번 . 현재행의 EMP_ID 컬럼 값을 int 자료형으로 얻어옴
				String empName= rs.getString("EMP_NAME"); //이름
				String empNo= rs.getString("EMP_NO"); // 주민등록번호
				String email=rs.getString("EMAIL"); // 이메일
				String phone=rs.getString("PHONE"); // 전화번호
				String deptCode=rs.getString("DEPT_CODE"); //부서코드
				String jobCode=rs.getString("JOB_CODE"); // 직급코드
				String salLevel=rs.getString("SAL_LEVEL"); // 급여등급
				int salary=rs.getInt("SALARY"); //급여
				double bonus=rs.getDouble("BONUS"); //보너스율
				int managerId=rs.getInt("MANAGER_ID"); // 관리자 사번
				Date hireDate=rs.getDate("HIRE_DATE"); // 입사일(java.sql.Date)
				Date entDate=rs.getDate("ENT_DATE"); // 퇴사일 
				char entYn=rs.getString("ENT_YN").charAt(0); // 퇴직여부
				//rs.getChar()는 존재하지 않음
				//왜 ? 자바에서는 문자 하나(char)의 개념이 있지만
				//DB에서는 오로지 문자열 개념만 존재함
				// ->String.chartAt(0)을 이용한다

				//얻어온 컬럼 값으로 객체 생성 후 초기화

				Employee emp = new Employee(empId, empName, empNo, email, phone, deptCode, jobCode, salLevel, salary, bonus, managerId, hireDate, entDate, entYn) ;

				// empList에 추가

				empList.add(emp);

			}

		}catch(Exception e) {
			//exception : 모든 예외의 최상위 부모
			//->try에서 발생하는 모든 예외를 잡아서 처리
			e.printStackTrace();

		} finally {
			// 7) 사용한 JDBC 자원 반환
			try {
				if(rs !=null) rs.close();
				if(stmt != null) stmt.close();
				if(conn != null) conn.close();
			} catch(Exception e) {
				e.printStackTrace();

			}
		}

		// 8) 호출부로 List 반환



		return empList;
	}

	/** 사번으로 사원 정보 조회 DAO
	 * @param input
	 * @return
	 */

	public Employee selectOne(int input) {

		//Employee emp = new Employee();
		//초기화 되어서 값을 null 로 가지고 있다.
		//Employee emp = null;
		// 아무것도 참조하지 않는다
		// 두개가 뭐가 다름?

		Employee emp = null;
		//Employee emp = new Employee();

		//왜 null 값을 넣어야? null 조건문은 사용하기 위해서 처음에 null 값으로 만들어 놓은것

		Connection conn = null;
		Statement stmt = null;
		ResultSet rs = null;

		try {

			Class.forName("oracle.jdbc.driver.OracleDriver");

			conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "hgh", "hgh1234");

			stmt = conn.createStatement();

			rs = stmt.executeQuery(" SELECT * FROM EMPLOYEE2 WHERE EMP_ID = '" +input+"'" );

			// 조회 결과가 있다면 1행 밖에 나오지 않으므로
			//while대신 if문을 사용한다.
			if(rs.next()) {
				// 조회 결과가 있으면 rs.next() == true --> if 문 수행
				// 조회 결과가 없으면 rs.next() == false --> if 문 수행X --> Employee 객체 생성 X
				int empId= rs.getInt("EMP_ID"); 
				String empName= rs.getString("EMP_NAME"); 
				String empNo= rs.getString("EMP_NO"); 
				String email=rs.getString("EMAIL");
				String phone=rs.getString("PHONE"); 
				String deptCode=rs.getString("DEPT_CODE"); 
				String jobCode=rs.getString("JOB_CODE"); 
				String salLevel=rs.getString("SAL_LEVEL"); 
				int salary=rs.getInt("SALARY"); 
				double bonus=rs.getDouble("BONUS"); 
				int managerId=rs.getInt("MANAGER_ID"); 
				Date hireDate=rs.getDate("HIRE_DATE"); 
				Date entDate=rs.getDate("ENT_DATE"); 
				char entYn=rs.getString("ENT_YN").charAt(0); 			

				emp = new Employee(empId, empName, empNo, email, phone,
						deptCode, jobCode, salLevel, salary, bonus,
						managerId, hireDate, entDate, entYn) ;


			}



		} catch (Exception e) {
			e.printStackTrace();;
		} finally {

			try {
				if(rs !=null) rs.close();
				if(stmt != null) stmt.close();
				if(conn != null) conn.close();
			} catch(SQLException e) {
				e.printStackTrace();

			}

		}
		// 조회 결과가 있으면 Employee 객체 주소
		// 없으면 null 반환
		return emp;
	}

	public List<Employee> selectSalary(int input) {

		List<Employee> empList = new ArrayList<>();

		try {

			Class.forName("oracle.jdbc.driver.OracleDriver"); // 생략가능

			conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe" , "hgh", "hgh1234");

			stmt = conn.createStatement();

			rs = stmt.executeQuery("SELECT * FROM EMPLOYEE2 WHERE SALARY>="+input);

			while(rs.next()) {
				// rs.next() : 다음 행이 있으면 true, 호출 시 마다 다음 행으로 이동
				int empId= rs.getInt("EMP_ID"); // 사번 . 현재행의 EMP_ID 컬럼 값을 int 자료형으로 얻어옴
				String empName= rs.getString("EMP_NAME"); //이름
				String empNo= rs.getString("EMP_NO"); // 주민등록번호
				String email=rs.getString("EMAIL"); // 이메일
				String phone=rs.getString("PHONE"); // 전화번호
				String deptCode=rs.getString("DEPT_CODE"); //부서코드
				String jobCode=rs.getString("JOB_CODE"); // 직급코드
				String salLevel=rs.getString("SAL_LEVEL"); // 급여등급
				int salary=rs.getInt("SALARY"); //급여
				double bonus=rs.getDouble("BONUS"); //보너스율
				int managerId=rs.getInt("MANAGER_ID"); // 관리자 사번
				Date hireDate=rs.getDate("HIRE_DATE"); // 입사일(java.sql.Date)
				Date entDate=rs.getDate("ENT_DATE"); // 퇴사일 
				char entYn=rs.getString("ENT_YN").charAt(0); // 퇴직여부
				//rs.getChar()는 존재하지 않음
				//왜 ? 자바에서는 문자 하나(char)의 개념이 있지만
				//DB에서는 오로지 문자열 개념만 존재함
				// ->String.chartAt(0)을 이용한다

				//얻어온 컬럼 값으로 객체 생성 후 초기화

				Employee emp = new Employee(empId, empName, empNo, email, phone, deptCode, jobCode, salLevel, salary, bonus, managerId, hireDate, entDate, entYn) ;

				// empList에 추가

				empList.add(emp);

			}


		}catch(Exception e) {
			e.printStackTrace();
		}finally {

			try {
				if(rs !=null) rs.close();
				if(stmt != null) stmt.close();
				if(conn != null) conn.close();
			} catch(SQLException e) {
				e.printStackTrace();

			}

		}

		return empList;

	}

	/**
	 * 
	 * @param emp
	 * @return
	 */

	public int insertEmployee(Employee emp) {

		int result = 0;


		try {
			//1) Orcale JDBC Driver 메모리 로드
			Class.forName("oracle.jdbc.driver.OracleDriver");
			//2) DB 연결 작업(Connection 얻어오기)

			conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe" , "hgh", "hgh1234");
			// DriverManager : Connection 생성 메소드 제공 
			//3) 수행할 SQL 작성
			conn.setAutoCommit(false);
			String sql = "INSERT INTO EMPLOYEE2 VALUES( ? , ? , ? , ?, ?, ?, ?, 'S1', ?, ?, NULL ,SYSDATE,NULL,'N')";

			//Statement : 커넥션 생성 -SQL 작성 -Statement 객체 생성 -SQL 수행 후 결과 반환

			//PreparedStatement : 커넥션 생성 -SQL 작성(? 사용) - PreparedStatement 객체 생성 (SQL 적재)
			//						- 위치 홀더에 알맞는 값 대입 -SQL 수행 후 결과 반환

			//PreparedStatement 객체 생성 (SQL 적재)
			pstmt = conn.prepareStatement(sql);

			// 위치홀더에 알맞는 값 대입
			// pstmt.set[Type](위치홀더 순서, 값)

			pstmt.setInt(1, emp.getEmpId()); // 입력 받은 사번을 1번 ?(위치홀더)에 세팅
			pstmt.setString(2, emp.getEmpName());
			pstmt.setString(3, emp.getEmpNo());
			pstmt.setString(4, emp.getEmail());
			pstmt.setString(5, emp.getPhone());
			pstmt.setString(6, emp.getDeptCode());
			pstmt.setString(7, emp.getJobCode());
			pstmt.setInt(8, emp.getSalary());
			pstmt.setDouble(9, emp.getBonus());

			// SQL 수행 후 결과 반환 받기
			// 1) Statement - SELECT         : stmt.executeQuery(sql); 
			// 2) PreparedStatement - SELECT : pstmt.executeQuery(); 

			//******** DML 수행 시 executeUpdate 사용
			// 3) Statement -DML             : stmt.executeUpdate(sql);
			// 4) PreparedStatement - DML    : pstmt.executeUpdate();

			result = pstmt.executeUpdate();
			// INSERT , UPDATE ,DELET가 성공한 행의 개수를 반환
			// 조건에 맞는 행이 없으면 0을 반환
			if(result>0) {
				conn.commit(); //DML 성공시 commit 수행
			} else {
				conn.rollback(); //DML 실패 시 rollback 수행
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {

			try {
				if(pstmt!=null)pstmt.close();
				if(conn!=null)conn.close();

			} catch (SQLException e) {
				e.printStackTrace();
			}

		}

		return result;
	}

	public int deleteEmployee(Employee emp) {

		int result = 0 ;

		try {

			//1) Orcale JDBC Driver 메모리 로드
			Class.forName("oracle.jdbc.driver.OracleDriver");
			//2) DB 연결 작업(Connection 얻어오기)

			conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe" , "hgh", "hgh1234");
			// DriverManager : Connection 생성 메소드 제공 

			conn.setAutoCommit(false); // 자동 커밋 기능 비활성화
			// --> 활성화 상태일 경우 SQL 수행 되자마자 COMMIT이 되버림
			// --> 자동 커밋을 비활성화 시켜도
			//     conn.close()가 실행되면 남은 트랜잭션 내용이 모두 commit 된다.



			//3) 수행할 SQL 작성

			String sql = "DELETE FROM EMPLOYEE2 WHERE EMP_ID=?";
			pstmt = conn.prepareStatement(sql);

			// 위치홀더에 알맞는 값 대입
			// pstmt.set[Type](위치홀더 순서, 값)

			pstmt.setInt(1, emp.getEmpId()); // 입력 받은 사번을 1번 ?(위치홀더)에 세팅

			result = pstmt.executeUpdate();

			//******** 트랜잭션 제어 **********
			if(result>0) {
				conn.commit(); //DML 성공시 commit 수행
			} else {
				conn.rollback(); //DML 실패 시 rollback 수행
			}

		} catch(Exception e) {
			e.printStackTrace();
		} finally {

			try {
				if(pstmt!=null)pstmt.close();
				if(conn!=null)conn.close();

			} catch (SQLException e) {
				e.printStackTrace();
			}

		} 


		return result;

	}


	/** 사번으로 사원 정보 수정 DAO (PreparedStatement)
	 * @param emp
	 * @return result
	 */
	public int updateEmployee(Employee emp) {

		int result = 0; // 결과 저장용 변수

		try {
			//oracle jdbc driver 메모리 로드
			Class.forName("oracle.jdbc.driver.OracleDriver");
			// 커넥션 생성

			conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe" , "hgh" , "hgh1234");

			// 자동 커밋 비활성
			conn.setAutoCommit(false);
			//sql 작성(위치 홀더 포함)
			String sql = "UPDATE EMPLOYEE2 SET EMAIL = ?, PHONE = ?, SALARY = ? WHERE EMP_ID=?";
			// ? 는 ''를 받아온다

			//PreparedStatement 생성
			pstmt = conn.prepareStatement(sql);
			//위치 홀더에 알맞은 값 대입

			//setString() 을 통해 위치홀더에 문자열 값을 대입하면
			// 문자열 양쪽에 ''(홑따옴표)가 포함된 상태로 추가!


			// ex)pstmt.setString(1, "user");
			//    --> 위치 홀더 자리      'user'

			pstmt.setString(1, emp.getEmail());
			pstmt.setString(2, emp.getPhone());

			//setInt()는 ''붙지 않음
			pstmt.setInt(3, emp.getSalary());
			pstmt.setInt(4, emp.getEmpId());
			//SQL 수행
			result = pstmt.executeUpdate();

			// 트랜잭션 제어

			if(result>0) {
				conn.commit(); //DML 성공시 commit 수행
			} else {
				conn.rollback(); //DML 실패 시 rollback 수행
			}

		}catch(Exception e) {
			e.printStackTrace();
		}finally {

			try {
				if(pstmt!=null)pstmt.close();
				if(conn!=null)conn.close();

			} catch (SQLException e) {
				e.printStackTrace();
			}

		}

		return result;
	}


	/** 사번으로 사원 정보 수정 DAO (Statement)
	 * @param emp
	 * @return result
	 */
	public int updateEmployee2(Employee emp) {

		int result = 0; // 결과 저장용 변수

		try {
			//oracle jdbc driver 메모리 로드
			Class.forName("oracle.jdbc.driver.OracleDriver");
			// 커넥션 생성

			conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe" , "hgh" , "hgh1234");

			// 자동 커밋 비활성
			conn.setAutoCommit(false);
			//sql 작성(위치 홀더 포함) (문자열 데이터 양쪽에 ''붙이기 잊지 말자!!)
			String sql = "UPDATE EMPLOYEE2 SET EMAIL = '"+ emp.getEmail() +"', PHONE = '"+emp.getPhone()+"', SALARY ="+emp.getSalary()+" WHERE EMP_ID= "+emp.getEmpId();
			//Statement 객체 생성
			stmt = conn.createStatement();

			//Sql 수행
			//result = stmt~~~
			//rs = stmt.executeQuery(sql);
			
			/// 수정하기
			// 트랜잭션 제어

			if(result>0) {
				conn.commit(); //DML 성공시 commit 수행
			} else {
				conn.rollback(); //DML 실패 시 rollback 수행
			}

		}catch(Exception e) {
			e.printStackTrace();
		}finally {

			try {
				if(pstmt!=null)pstmt.close();
				if(conn!=null)conn.close();

			} catch (SQLException e) {
				e.printStackTrace();
			}

		}

		return result;
	}


	/**
	 * 부서코드, 보너스율을 입력 받아 해당 부서의 보너스를 모두 수정
	 * @param emp
	 * @return
	 */
	public int updateBonus(Employee emp) {

		int result = 0;

		try {

			Class.forName("oracle.jdbc.driver.OracleDriver");

			conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe" , "hgh" , "hgh1234");
			conn.setAutoCommit(false);

			pstmt = conn.prepareStatement("UPDATE EMPLOYEE2 SET BONUS=? WHERE DEPT_CODE=?");

			pstmt.setDouble(1, emp.getBonus());
			pstmt.setString(2, emp.getDeptCode());
			
			result = pstmt.executeUpdate();

			if(result>0) {
				conn.commit(); //DML 성공시 commit 수행
			} else {
				conn.rollback(); //DML 실패 시 rollback 수행
			}

		}catch(Exception e) {
			e.printStackTrace();
		} finally {

			try {
				if(pstmt!=null)pstmt.close();
				if(conn!=null)conn.close();

			} catch (SQLException e) {
				e.printStackTrace();
			}

		}

		return result;
	}	
	
	

}

